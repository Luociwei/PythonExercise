# -*- coding: utf-8 -*-
import time
from mix.driver.core.bus.axi4_lite_bus import AXI4LiteBus
from mix.driver.core.utility.data_operate import DataOperate


__author__ = 'huangzicheng@SmartGiant'
__version__ = '0.0.3'


class MIXSquareMeterSGDef:

    DEFAULT_TIMEOUT = 1000
    DEFAULT_DELAY = 0.001
    CONFIG_REGISTER = 0x10
    WAIT_TIME_REGISTER = 0x11
    FREQ_REGISTER = 0x14
    HP_REGISTER = 0x15
    SET_MEASURE_REGISTER = 0x13
    DUTY_ALL_REGISTER = 0x50
    DUTY_HIGH_REGISTER = 0x58
    DUTY_N_REGISTER = 0x60
    FREQ_X_REGISTER = 0x20
    FREQ_Y_REGISTER = 0x28
    FREQ_XY_REGISTER = 0x30
    FREQ_XX_REGISTER = 0x38
    FREQ_N_REGISTER = 0x40
    REGISTER_SIZE = 1024

    CLOCK_ENABLE = (0x1 << 1)
    MEASURE_LEVEL_MASK = (0x1 << 2)
    IS_CLK1_LOCKED = (0x1 << 3)


class MIXSquareMeterSGException(Exception):

    def __init__(self, err_str):
        self._err_reason = '%s.' % (err_str)

    def __str__(self):
        return self._err_reason


class MIXSquareMeterSG(object):

    '''
    pl signal meter function class to control the signal meter

    ClassType = MIXSquareMeterSG

    Args:
        axi4_bus: instance(AXI4LiteBus)/string/None,  AXI4 lite bus instance or device path;
                                                      If None, will create Emulator.

    Examples:
        signal_meter = MIXSquareMeterSG('/dev/MIX_SIGNAL_METER')

        # example for measure AC signal
        signal_meter.start_measure(100, 1000)
        freq = signal_meter.measure_frequency('LP')
        duty = signal_meter.duty()
        print("freq={}, duty={}".format(freq, duty))

    '''

    rpc_public_api = ['select_clock', 'is_clk1_unlocked', 'start_measure',
                      'measure_frequency', 'level', 'duty']

    def __init__(self, axi4_bus=None):
        if isinstance(axi4_bus, basestring):
            self.axi4_bus = AXI4LiteBus(axi4_bus, MIXSquareMeterSGDef.REGISTER_SIZE)
        else:
            self.axi4_bus = axi4_bus

        self.__measure_state = 0
        self.__sample_rate = 125000000
        self._enable()

    def __del__(self):
        self._disable()

    def _enable(self):
        '''
        MIXSquareMeterSG IP enable function
        '''
        rd_conf_val = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.CONFIG_REGISTER, 1)
        config_data = (rd_conf_val[0] & ~ 0x1)
        self.axi4_bus.write_8bit_inc(
            MIXSquareMeterSGDef.CONFIG_REGISTER, [config_data])
        config_data = config_data | 0x01
        self.axi4_bus.write_8bit_inc(
            MIXSquareMeterSGDef.CONFIG_REGISTER, [config_data])

    def _disable(self):
        '''
        MIXSquareMeterSG IP disable function
        '''
        rd_conf_val = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.CONFIG_REGISTER, 1)[0]
        config_data = (rd_conf_val & ~ 0x1)
        self.axi4_bus.write_8bit_inc(
            MIXSquareMeterSGDef.CONFIG_REGISTER, [config_data])

    def select_clock(self, clock):
        '''
        Select reference clock source

        Args:
            clock:  string, ['clk0', 'clk1'], 'clk0' is clock generated by crystal on baseboard.
                                              'clk1' is clock generated by external crystal.

        Returns:
            string, 'done', return 'done', if execute successfully.

        '''
        assert clock in ['clk0', 'clk1']

        rd_conf_val = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.CONFIG_REGISTER, 1)
        if 'clk0' == clock:
            config_data = (rd_conf_val[0] & (~ MIXSquareMeterSGDef.CLOCK_ENABLE))
        else:
            config_data = (rd_conf_val[0] | MIXSquareMeterSGDef.CLOCK_ENABLE)

        self.axi4_bus.write_8bit_inc(
            MIXSquareMeterSGDef.CONFIG_REGISTER, [config_data])
        return "done"

    def is_clk1_unlocked(self):
        '''
        Check if 'clk1' is unlocked

        Returns:
            Boolean, [True, False], return True, if 'clk1' is unlocked, otherwise return False.

        '''
        rd_conf_val = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.CONFIG_REGISTER, 1)
        is_locked = rd_conf_val[0] & MIXSquareMeterSGDef.IS_CLK1_LOCKED
        if 0x00 == is_locked:
            return True
        else:
            return False

    def start_measure(self, time_ms, sample_rate):
        '''
        Start measure input signal

        Args:
            time_ms:         int, [1~2000], unit ms, the total time in ms to measure.
            sample_rate:     int, [1~125000000], unit SPS, ADC sample rate in SPS.

        Returns:
            string, 'done', return 'done', if execute successfully.

        '''
        assert isinstance(time_ms, int)
        assert 1 <= time_ms <= 2000
        assert isinstance(sample_rate, int)
        assert 1 <= sample_rate <= 125000000

        self.__sample_rate = sample_rate
        wr_data = DataOperate.int_2_list(time_ms, 2)
        self.axi4_bus.write_8bit_inc(
            MIXSquareMeterSGDef.WAIT_TIME_REGISTER, wr_data)
        self.axi4_bus.write_8bit_inc(
            MIXSquareMeterSGDef.FREQ_REGISTER, [0x00])
        self.axi4_bus.write_8bit_inc(
            MIXSquareMeterSGDef.SET_MEASURE_REGISTER, [0x01])
        rd_data = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.FREQ_REGISTER, 1)

        last_time = time.time()
        # time.time() unit needs to be converted to ms
        while ((rd_data[0] != 0x01) and
               ((time.time() - last_time) * 1000 < (time_ms + MIXSquareMeterSGDef.DEFAULT_TIMEOUT))):
            time.sleep(MIXSquareMeterSGDef.DEFAULT_DELAY)
            rd_data = self.axi4_bus.read_8bit_inc(
                MIXSquareMeterSGDef.FREQ_REGISTER, 1)

        if((time.time() - last_time) * 1000 >= (time_ms + MIXSquareMeterSGDef.DEFAULT_TIMEOUT)):
            raise MIXSquareMeterSGException('SignalMeter Measure time out')
            self.__measure_state = 0
        self.__measure_state = 1
        return "done"

    def measure_frequency(self, measure_type):
        '''
        Measure input signal frequency

        Args:
            measure_type:  string, ['HP', 'LP'], type of measurement.

        Returns:
            float, input signal frequency measured by this IP.

        '''
        assert measure_type in ['HP', 'LP']

        if self.__measure_state == 0:
            return 0

        if measure_type == 'HP':
            freq = self._measure_frequency_hp()
        else:
            freq = self._measure_frequency_lp()

        return freq

    def level(self):
        '''
        Measure input signal voltage level

        Returns:
            int, [0, 1],  0 for low level, 1 for high level.

        '''
        value = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.CONFIG_REGISTER, 1)[0]
        return 1 if (value & MIXSquareMeterSGDef.MEASURE_LEVEL_MASK) else 0

    def duty(self):
        '''
        Measure input signal duty

        Returns:
            float, [0~100], signal duty.

        '''
        if(self.__measure_state == 0):
            rd_data = self.axi4_bus.read_8bit_inc(
                MIXSquareMeterSGDef.CONFIG_REGISTER, 1)
            if(rd_data[0] & 0x04 == 0x04):
                return(100, '%')
            else:
                return(0, '%')
        rd_data = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.DUTY_ALL_REGISTER, 8)
        duty_all = DataOperate.list_2_int(rd_data)
        rd_data = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.DUTY_HIGH_REGISTER, 8)
        duty_high = DataOperate.list_2_int(rd_data)

        duty = (float(duty_high) / duty_all) * 100
        return duty

    def _measure_frequency_hp(self):
        '''
        measure frequency in high-precision

        Returns:
            float, value, unit Hz.

        '''
        rd_data = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.HP_REGISTER, 2)
        sys_divide = DataOperate.list_2_int(rd_data)
        if(sys_divide == 0):
            sys_divide = 1
        rd_data = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.FREQ_X_REGISTER, 8)
        freq_x_sum = DataOperate.list_2_int(rd_data)
        rd_data = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.FREQ_Y_REGISTER, 8)
        freq_y_sum = DataOperate.list_2_int(rd_data)
        rd_data = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.FREQ_XY_REGISTER, 8)
        freq_xy_sum = DataOperate.list_2_int(rd_data)
        rd_data = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.FREQ_XX_REGISTER, 8)
        freq_xx_sum = DataOperate.list_2_int(rd_data)
        rd_data = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.FREQ_N_REGISTER, 4)
        freq_N = DataOperate.list_2_int(rd_data)
        k_1 = freq_N * freq_xy_sum - freq_y_sum * freq_x_sum
        k_2 = freq_N * freq_xx_sum - freq_x_sum * freq_x_sum
        freq = float(sys_divide) * self.__sample_rate * k_2 / k_1
        return freq

    def _measure_frequency_lp(self):
        '''
        measure frequency in low-precision

        Returns:
            float, value, unit Hz.
        '''
        rd_data = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.DUTY_ALL_REGISTER, 8)
        duty_all = DataOperate.list_2_int(rd_data)
        rd_data = self.axi4_bus.read_8bit_inc(
            MIXSquareMeterSGDef.DUTY_N_REGISTER, 4)
        duty_N = DataOperate.list_2_int(rd_data)
        freq = float(duty_N) * self.__sample_rate / duty_all
        return freq
