
#
# CCG2 devices support SWD transports only.
#
source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME ccgx
}

global g_use_host_interface
set g_use_host_interface 0

# This enables zynq adapter's call into CCGX Chip Acquire sequence before we even try to request DPIDR.
zynq_auto_acquire

reset_config none

# Work-area is a space in RAM used for flash programming
# By default use 4kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x1000
}

if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x0bb11477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME $_CHIPNAME 0 0 0 0 $_TARGETNAME

adapter_khz 3000

# Code largely borrowed from psoc4.cfg, which explains the strange psoc reset seq
# Main difference here vs psoc is that to avoid the DAP reset, the psoc acq sequence happens after a soft reset

# perform a soft reset
cortex_m reset_config sysresetreq

targets

proc ccgx_use_host_interface {} {
	ccgx use_host_interface
	global g_use_host_interface
	set g_use_host_interface 1
}

proc ocd_process_reset_inner { MODE } {
	global _CHIPNAME
	set t $_CHIPNAME.cpu

	# If this target must be halted...
	set halt -1
	if { 0 == [string compare $MODE halt] } {
		set halt 1
	}
	if { 0 == [string compare $MODE init] } {
		set halt 1;
	}
	if { 0 == [string compare $MODE run ] } {
		set halt 0;
	}
	if { $halt < 0 } {
		return -code error "Invalid mode: $MODE, must be one of: halt, init, or run";
	}

	$t invoke-event reset-start
	$t invoke-event reset-assert-pre

	$t arp_reset assert 0
	$t invoke-event reset-assert-post
	$t invoke-event reset-deassert-pre
	$t arp_reset deassert 0
	$t invoke-event reset-deassert-post
	
	# For Flash Programming, perform acquire and return here here.
	# If General GDB is needed, remove this!
	zynq_psoc_acquire

	global g_use_host_interface
	if {$g_use_host_interface == 1} {
		return 0
	}

	# Pass 1 - Now wait for any halt (requested as part of reset
	# assert/deassert) to happen.  Ideally it takes effect without
	# first executing any instructions.
	if { $halt } {
		# Now CCG2 CPU should loop in system ROM
		$t arp_waitstate running 200
		$t arp_halt

		# Catch, but ignore any errors.
		catch { $t arp_waitstate halted 1000 }

		# Did we succeed?
		set s [$t curstate]

		if { 0 != [string compare $s "halted" ] } {
			return -code error [format "TARGET: %s - Not halted" $t]
		}

		# Check if PSoC CPU is stopped in system ROM
		set pc [reg pc]
		regsub {pc[^:]*: } $pc "" pc
		if { $pc < 0x10000000 || $pc > 0x1000ffff } {
			return -code error [format "TARGET: %s - Not halted in system ROM, use 'reset_config none'" $t]
		}

		# Set registers to reset vector values
		mem2array value 32 0 2
		reg pc [expr $value(1) & 0xfffffffe ]
		reg msp $value(0)

	}

	#Pass 2 - if needed "init"
	if { 0 == [string compare init $MODE] } {
		set err [catch "$t arp_waitstate halted 5000"]

		# Did it halt?
		if { $err == 0 } {
			$t invoke-event reset-init
		}
	}

	$t invoke-event reset-end
}

############################################################
# See comment 'Reset, bloody PSoC 4 reset' in psoc4.cfg.
############################################################
proc reset_init_retry { allowance } {
	# reset target and call any init scripts
	set attempt 0
	set reset_status 0
	while { 1 } {
		set reset_status [catch {reset init}]
		if {$reset_status != 0 && $attempt < $allowance} {
			echo "** Unable to reset target, retrying..."
			incr attempt
		} else {
			break
		}
	}
	if {$reset_status != 0} {
		set exit 0
		program_error "** Unable to reset target **" $exit
	}
	return $reset_status
}

proc chip_protect_status {} {
	reset init
	reset
	ccgx chip_protect_status
	return 0
}
